# 14장 전역 변수의 문제점

### 변수의 생명 주기

변수는 선언에 의해 생성되고, 할당을 통해 값을 얻는다. 이를 생명 주기라 하고, 만약 생명 주기가 없다면 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다.

변수는 자신이 선언된 위치에서 생성되고 소멸한다. 전역 변수의 생명주기는 애플리케이션의 생명 주기와 같지만, 지역변수는 함수가 호출되면 생성되고, 함수가 종료되면 소멸한다.

변수 선언은 선언문이 어디 있든 상관없이 가장 먼저 실행된다 (전역변수는). 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임에 실행되는 게 아니라 런타임 이전 자바스크립트 엔진에 의해 먼저 실행되는 것이다.

![image.png](attachment:ed81822a-e96c-4a06-8bdc-16991974fbd8:image.png)

foo()함수 내 지역변수는 **함수를 호출하면** x 변수의 선언문은 자바스크립트 엔진에 의해 가장 먼저 실행되어 x 변수가 선언되고 undefined로 초기화된다. 값이 할당되고, 함수가 종료되면 x 변수도 소멸한다.

→ **지역 변수의 생명 주기는 함수의 생명 주기와 일치**한다.

함수 내부에서 선언된 **지역 변수는 함수가 생성한 스코프에 등록**된다. 따라서 변수는 자신이 등록된 스코프가 소멸(메모리 해제) 될 때까지 유효하다. 스코프 소멸은 함수가 종료되면 소멸된다. 누군가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아있게 된다.

📌 예시

```jsx
var x = "global";

function foo() {
  console.log(x); // undefined
  var x = "local";
}

foo();
console.log(x); //global
```

**호이스팅은 스코프 단위로 동작**한다.

foo 함수 내부에서 선언된 지역 변수 x는 이미 선언되어 undefined로 초기화되어 있다. 따라서 전역 변수 x를 참조하는 것이 아니라 지역 변수 x를 참조해 값을 출력한다. 변수 할당문이 실행되기 전까진 undefined 값을 갖는다.

즉, **호이스팅**은 **변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작**하는 자바스크립트의 고유한 특징을 말한다.

### 전역 변수의 생명 주기

전역 코드는 호출과 같이 특별한 진입점이 없고, 코드가 로드되자마자 곧바로 해석되고 실행된다. 전역 코드는 반환문이 없기 때문에 마지막 문이 실행된 뒤 종료된다.

브라우저에서 전역 객체는 window이므로 브라우저 환경에서 **var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티**다. 즉, var 키워드로 선언한 전역 변수는 웹페이지를 닫을 때까지 유효하다.

![image.png](attachment:ee9100be-dd37-4cd8-947e-d29e24a23772:image.png)

→ var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.

### 전역 객체

**코드가 실행되기 전 단계**에서 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체다. 클라이언트 사이드 환경에서는 window, 서버사이드 환경에서는 global 개체를 의미한다.

### 전역 변수의 문제점

1. 암묵적 결합

   모든 코드가 전역 변수를 참조하고 변경할 수 있는 **암묵적 결합**을 허용하기 때문에 유효 범위가 클수록 가독성이 나빠지고 상태가 변경될 수 있는 위험성이 높아진다.

2. 긴 생명주기

   전역 변수는 생명 주기가 길다. **메모리 리소스도 오랜 기간 소비**한다.

   생명주기가 긴 전역 변수는 변수 이름이 중복될 가능성이 높다. (의도치 않은 재할당이 이루어질 수 있는 것이다.)

3. 스코프 체인 상에서 종점에 존재 → 검색 속도 느림

   전역 변수는 스코프 체인의 종점에 존재하기 때문에 변수를 검색할 때 가장 마지막에 검색기 때문에 검색 속도가 느리다.

4. 네임스페이스 오염

   **자바스크립트는 파일이 분리되어 있어도 전역 스코프를 공유**하기 때문에 동일한 이름으로 명명된 전역 변수가 같은 스코프 내 존재하면 의도치 않은 결과를 가져올 수 있다.

### 해결 방법

→ 전역 변수를 반드시 사용해야 할 이유를 찾지 못했다면 지역 변수를 사용해야 한다. **변수의 스코프는 좁을수록 좋다.**

1. **즉시 실행 함수**

   즉시 실행 함수는 함수 정의와 함께 호출되기 때문에 모든 코드를 즉시 실행 함수로 감싸면 모든 변수가 즉시 실행 함수의 지역 변수가 된다.

2. **네임스페이스 객체**

   ```jsx
   var MYAPP = {}; //전역 네임스페이스 객체

   MYAPP.name = "Lee";
   console.log(MYAPP.name);
   ```

   네임 스페이스 자체가 전역 변수에 할당되므로 좋은 방법은 아님

3. **모듈 패턴**

   변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈로 만든다. 클로저 기반으로 동작하며, **캡슐화**(객체의 상태를 나타내는 프로퍼티와 메서드를 하나로 묶는 것)까지 구현 가능하다. 자바스크립트는 public, private, protected와 같은 접근 제한자를 제공하지 않기 때문에 정보 은닉에 모듈 패턴이 유용하다.

   ```jsx
   var Counter = (function () {
     var num = 0; //private 변수

     //외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
     return {
       increase() {
         return ++num;
       },
       decrease() {
         return --num;
       },
     };
   })();

   //private 변수는 외부로 노출되지 않는다.
   console.log(Couter.num); //undefined

   console.log(Counter.increase); //1
   console.log(Counter.increase); //2
   console.log(Counter.decrease); //1
   ```

4. ES6 모듈

   ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공하기 때문에 var 키워드로 선언한 변수가 전역 변수가 아니며, window 객체의 프로퍼티도 아니게 된다.

   모던 브라우저 (Chrome 61, FF 60 …) 에서는 ES6 모듈을 사용할 수 있다. script 태그에 `type=”module”` 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 작동한다.
