# 26장 ES6 함수의 추가 기능

ES6 이전의 함수는 사용 목적에 따라 명확히 구분되지 않으며, 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서도 호출할 수 있다. → callable 하며 constructor

```jsx
var obj = {
  x: 10,
  f: function () {
    return this.x;
  },
};
// 프로퍼티 f에 바인딩된 함수는 callable, constructor

console.log(obj.f()); //프로퍼티 f에 바인딩된 함수를 메서드로서 호출

var bar = obj.f;
// 프로퍼티 f에 바인딩된 함수를 일반 함수로서 호출
console.log(bar()); // undefined

// 프로퍼티 f에 바인딩된 함수를 생성자 함수로서 호출
console.log(new obj.f()); //f{}
```

<aside>
📌

호출할 수 있는 객체를 callable이라 하며, 인스턴스를 생성할 수 있는 함수 객체를 constructor, 인스턴스를 생성할 수 없는 함수 객체를 non-constructor이라고 부른다.

</aside>

이러한 문제를 해결하기 위해 ES6에서는 함수르 사용 목적에 따라 세 가지 종류로 명확히 구분한다.

![image.png](attachment:060f53b1-b2f8-46e1-a05d-b0a146825b79:image.png)

### 메서드

```jsx
const obj = {
  x: 1,
  foo() {
    return this.x;
  }, // foo는 메서드
};
```

ES6 사양에서의 메서드는 메서드 축약 표현으로 정의된 함수 만을 의미한다.

ES6 사양에서 정의한 메서드는 인스턴스를 생성할 수 없는 non-constructor다. → 생성자 함수로서 호출할 수 없다 (new 키워드 X)

본연의 기능 (super)은 추가하고 constructor 기능은 제거했다.

### 화살표 함수

화살표를 사용해 기존 함수 정의 방식보다 간략하게 함수를 정의할 수 있으며, 내부 동작도 간략하다. this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용하다.

```jsx
const arrow = (x, y) => {}; // 매개변수 여러 개인 경우 소괄호 안에 매개변수 선언
const arrow = (x) => {}; // 매개변수 한 개인 경우 소괄호 생략 가능
const arrow = () => {}; // 매개변수 없는 경우 () 생략 불가
```

객체 리터럴을 반환하는 경우 객체 리터럴을 소괄호로 감싸주어야 한다. → 감싸지 않으면 함수 몸체를 감싸는 중괄호로 잘못 해석한다.

```jsx
const create = {id, content} => ({id, content});
```

화살표 함수도 즉시 실행함수로 사용할 수 있다. → 괄호로 감싼다.

```jsx
const	person	=	(name	=>	({
 sayHi()	{	return	`Hi?	My	name	is	${name}.`;	}
 }))('Lee');
 console.1og(person.5ayHi());	//	Hi?	My	na'ne	1s	L“
```

화살표 함수도 일급객체이므로 고차 함수로써 인수로 전달할 수 있다. 일반 함수 표현보다 간결해 가독성이 좋다.

```jsx
 [1,	2,	3].map(functlon	(v)	{
	return v*2;
	}
 //	E56
 [1,	2,	3].map(v	=>	v	*	2);	//	→	[	2,	4,	6	]
```

### 화살표 함수와 일반 함수의 차이

1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor이다.
2. 중복된 매개변수 이름을 선언해도 에러가 발생하지 않는다.
   1. 단, strict 모드에서 중복된 매개변수 이름을 선언하면에러가 발생한다.
3. 화살표 함수는 함수 자체의 this, arguments, super, [new.target](http://new.target) 바인딩을 갖지 않는다.
   1. 따라서 위의 것들을 참조하면 스코프 체인을 통해 상위 스코프를 참조한다.

### this

- 화살표 함수는 **자체적인 `this`를 가지지 않는다**.
- 화살표 함수 내부의 `this`는 **상위 스코프(외부 함수)의 `this`를 그대로 참조**한다 → 이를 **렉시컬 this**라고 부른다.
- 일반 함수는 호출 방식에 따라 `this`가 결정되지만, 화살표 함수는 생성될 때 주변 스코프의 `this`로 고정된다.
- 콜백 함수에서 `this` 문제를 해결하기 위해 화살표 함수를 많이 사용한다.
- `Array.prototype.map()` 같은 메서드에서 콜백에 화살표 함수를 사용하면, `this`를 의도한 대로 유지할 수 있다.

### **화살표 함수의 다른 특징**

- **`super`**: 화살표 함수도 `super`를 직접 가지지 않는다.
  ⇒ 상위 스코프의 `super`를 그대로 참조한다.
- **`arguments`**: 화살표 함수는 `arguments` 객체를 가지지 않는다.
  ⇒ 상위 스코프의 `arguments`를 참조한다.
  (하지만 전역에는 `arguments`가 없기 때문에 ReferenceError가 날 수 있음)
- **`bind`, `call`, `apply`**: 화살표 함수에 사용해도 `this`를 바꿀 수 없다.

### **화살표 함수로 메서드 정의는 피해야 한다**

- 객체나 클래스 메서드를 **화살표 함수**로 정의하면 안 된다.
- 이유: 화살표 함수는 `this`가 객체를 가리키지 않고 전역(또는 상위 스코프)을 가리키기 때문.
- 메서드는 항상 **ES6 메서드 축약 표기**나 **일반 함수**로 작성해야 한다.

### **Rest 파라미터**

- *`...`*를 사용하여 남는 인수들을 **배열로** 받는다.
- 예시:
  ```jsx
  function foo(...rest) {
    console.log(rest); // [1, 2, 3]
  }
  foo(1, 2, 3);
  ```
- 규칙:
  - 항상 **마지막 매개변수**여야 한다.
  - **하나만** 사용할 수 있다.
- Rest 파라미터는 함수의 `length`(기대하는 인자 수)에 영향을 주지 않는다.

### **매개변수 기본값 (Default Parameters)**

- 매개변수에 기본값을 줄 수 있다.
  ```jsx
  function sum(x = 0, y = 0) {
    return x + y;
  }
  ```
- 기본값은 **인수가 전달되지 않았거나**, **`undefined`를 전달한 경우**에만 적용된다.
- 기본값은 함수 `length`에 영향을 주지 않는다.
- **Rest 파라미터**에는 기본값을 지정할 수 없다
